//définition des E/S et du code associé, doit être fait avant la définition du modèle pour que les E/S ne soient pas traitées par le modèle 
#pragma_vhdl_generic_directive{ n:integer:=32;}#pragma
#pragma_vhdl_entity{ A  : buffer  std_logic_vector(N - 1 downto 0) ;}#pragma
#pragma_vhdl_entity{ B  : buffer  std_logic_vector(N - 1 downto 0) ;}#pragma

#pragma_vhdl_entity{ Quotient  : buffer std_logic_vector(N - 1 downto 0) ;}#pragma
#pragma_vhdl_entity{ Remainder  : buffer std_logic_vector(N - 1 downto 0) ;}#pragma
 
#pragma_vhdl_entity{ RESULT_AVAILABLE_OUT  : out  std_logic;}#pragma


//TODO: generer les differents etats et action compute en fonction du nombre de bits souhaité
//permettre l'utilisation  dans les généric  de (N*2)-1

//définition du modèle

->0?SRESET;
=>0?RESETN;

0->1:START;
1->2?RESULT_AVAILABLE;
2->0:INC;
 
#pragma_vhdl_promote_to_buffer{INC,START  }#pragma   

 #pragma_vhdl_demote_to_signal{RESULT_AVAILABLE }#pragma  
#pragma_vhdl_entity{ Error      : out std_logic;}#pragma


//////////////////////////////////////////////////
#pragma_vhdl_pre_entity{ 
-- I don't know yet how to use libraries in ghdl
-- library work;
-- use work.diviseur32bits_pack.all;
}#pragma

//////////////////////////////////////////////////   
#pragma_vhdl_architecture_pre_begin{ 
component diviseur32bits
generic (
		N : INTEGER := 32;
		M : INTEGER := 64);
port (
		CK               : in     std_logic;
		RESETN           : in     std_logic;
		STATE_NUMBER     : out    std_logic_vector( 5 downto 0);
		A                : in     std_logic_vector ( N-1  downto  0 ) ;
		B                : in     std_logic_vector ( N-1  downto  0 ) ;
		START            : in     std_logic;
		COMPUTE          : buffer std_logic;
		ERROR            : out    std_logic ;
		QUOTIENT         : buffer std_logic_vector ( N-1  downto  0 ) ;
		REMAINDER        : buffer std_logic_vector ( N-1  downto  0 ) ;
		RESULT_AVAILABLE : out    std_logic);
end component;
}#pragma
//////////////////////////////////////////////////   
#pragma_vhdl_architecture_post_begin{ 

--------------------------------------------------------------------------------
-- Finite State Machine port map vhdl file autogenerated by FsmProcess V 1.0 B. VANDEPORTAELE LAAS-CNRS 2016
--------------------------------------------------------------------------------
diviseur32bits_u0 : diviseur32bits
generic map (
		N => 32,
		M => 64)
port map(
		CK => CK,
		RESETN => RESETN,
		state_number =>  open,
		A => A,
		B => B,
		START => START,
		COMPUTE => open,
		ERROR => ERROR,
		QUOTIENT => QUOTIENT,
		REMAINDER => REMAINDER,
		RESULT_AVAILABLE => RESULT_AVAILABLE);
--create values for A and B using INC output of the FSM model
 
RESULT_AVAILABLE_OUT<=RESULT_AVAILABLE;

Process (ck, RESETN)
	begin
	if RESETN='0' then  A <= (others=>'0');B <= (others=>'0'); 
	elsif ck'event and ck='1' then 
	  if SRESET='1'then   --init synchrone
		 A <= (others=>'0');B <= (others=>'0'); 
	  elsif INC='1' then
		if (not A(9 downto 0 )=0) then 
		--if (not A=0) then 
			A<=(others=>'0');
			B<=B+1;
		else 
			A<=A+1;
		end if;
	 end if;
	end if;
end process;
}#pragma

 
//run for 30000us
#pragma_vhdl_testbench{  
---------------------------------------	
 SRESET<='1';
wait for ck_period;
SRESET<='0';
wait for ck_period*400000;
 
---------------------------------------	
}#pragma

