/***
 * Excerpted from "The Definitive ANTLR 4 Reference",
 * published by The Pragmatic Bookshelf.
 * Copyrights apply to this code. It may not be used to create training material, 
 * courses, books, articles, and the like. Contact us if you are in doubt.
 * We make no guarantees that this code is fit for any purpose. 
 * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information.
 ***/
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.misc.MultiMap;
import org.antlr.v4.runtime.misc.OrderedHashSet;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;

import java.io.FileInputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Set;

import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;



//TODO: comprendre pourquoi antlr ne genere par le fichier FsmParser.java  mais uniquement le class...

public class FsmProcess {

	static StringBuilder bufDot;
	static StringBuilder bufVhdl;	
	static FiniteStateMachine fsm=new FiniteStateMachine();

	//////////////////////////////////////////////////
	static public void generateVhdl()
	{
		bufVhdl.append("--/////////////////////////////////////////////////////////////////////////////////////////////////////////\n");
		bufVhdl.append("-- Finite State Machine .vhdl  autogenerated by FsmProcess B. VANDEPORTAELE LAAS/CNRS 2016\n");
		bufVhdl.append("--/////////////////////////////////////////////////////////////////////////////////////////////////////////\n");
		bufVhdl.append("library	ieee;\nuse		ieee.std_logic_1164.all;\nuse		ieee.std_logic_unsigned.all;\nuse		ieee.std_logic_arith.all;\nentity ");
		bufVhdl.append(fsm.name);
		bufVhdl.append(" is\n	port (\n");
		bufVhdl.append("		ck,arazb								: in  std_logic;\n");

		/*
State s0=new State();
State s1=new State();
State s2=new State();
s0.isInit=true;
s1.isInit=false;
s2.isInit=false;
s0.name="0";
s1.name="1";
s2.name="2";

fsm.hmapState.put("etat0",s0);
fsm.hmapState.put("etat2",s2);
fsm.hmapState.put("etat1",s1);


bufVhdl.append("nb elements: ");
bufVhdl.append(fsm.hmapState.size());

bufVhdl.append("\n");

State s=fsm.getStateFromName("etat0");
if (s!=null)
	{
	bufVhdl.append("etat1: ");
	bufVhdl.append(s.isInit);
	bufVhdl.append("\n");
	}

if (!fsm.addState("etat3",s0))
	bufVhdl.append("premier essai raté\n ");

if (!fsm.addState("etat3",s0))
	bufVhdl.append("second essai raté\n ");

fsm.addState("etat4",s0);
		 */



		for (int n=0;n<fsm.hmapInput.size();n++)
		{
			bufVhdl.append("		");
			bufVhdl.append(fsm.inputs.get(n).name);
			bufVhdl.append(": in  std_logic;\n");
		}
		/*
	for (int n=0;n<fsm.outputsNames.size();n++)
	{
	bufVhdl.append("		");
	bufVhdl.append(fsm.outputsNames.get(n));
	bufVhdl.append(": out  std_logic");
	if (n!=fsm.outputsNames.size()-1)
		bufVhdl.append(";\n");
	else	
		bufVhdl.append(");\n");		
	}

	bufVhdl.append("end ");	
	bufVhdl.append(fsm.name);
	bufVhdl.append(";\n\n");
	bufVhdl.append("architecture a of ");
	bufVhdl.append(fsm.name);
	bufVhdl.append(" is \n");
	bufVhdl.append("type fsm_state is (");
	for (int n=0;n<fsm.statesNames.size();n++)
	{
		//prefix state name with state_
		bufVhdl.append("state_");
		bufVhdl.append(fsm.statesNames.get(n));
		if (n!=fsm.statesNames.size()-1)
			bufVhdl.append(", ");
	}
	bufVhdl.append(");\n");
	bufVhdl.append("signal etat_present, etat_suivant : etat_mae;\n");

	bufVhdl.append("begin\n");
	bufVhdl.append("process (ck, arazb)\nbegin\n    if (arazb='0') then etat_present <=");
	bufVhdl.append("state_");
	bufVhdl.append(fsm.statesNames.get(0));
	bufVhdl.append(";\n");
	bufVhdl.append("    elsif ck'event and ck='1' then etat_present<=etat_suivant;\n");
	bufVhdl.append("    end if;\n");
	bufVhdl.append("end process;\n\n");

	bufVhdl.append("process (etat_present");
	for (int n=0;n<fsm.inputsNames.size();n++)
	{
		bufVhdl.append(", ");
		bufVhdl.append(fsm.inputsNames.get(n));
	}
	bufVhdl.append(")\nbegin\n");
	bufVhdl.append("    case etat_present is\n");
	//pour chaque état, il peut y avoir plusieurs transitions, la première if, les suivantes elsif et finalement en plus le maintien dans l'état courant
	for (int n=0;n<fsm.statesNames.size();n++)
 	{
		bufVhdl.append("      when state_");	//prefix state name with state_
		bufVhdl.append(fsm.statesNames.get(n));

		int transitionFromThisStateNumber=0;
		for (int m=0;m<fsm.transitions.size();m++)
		{
			if (fsm.transitions.get(m).origin.equals(fsm.statesNames.get(n))) //is it a transition from this state
			{
				transitionFromThisStateNumber++;
				if (transitionFromThisStateNumber==1)
					bufVhdl.append(" => if ( ");
				else
					bufVhdl.append("                   elsif ( ");
				bufVhdl.append(fsm.transitions.get(m).condition);
				bufVhdl.append(" ) then etat_suivant <= state_");
				bufVhdl.append(fsm.transitions.get(m).destination);
				bufVhdl.append(";\n");
			}
		}
		if (transitionFromThisStateNumber!=0)
			bufVhdl.append("                     else	");
		bufVhdl.append("etat_suivant <= state_");
		bufVhdl.append(fsm.statesNames.get(n));
		bufVhdl.append(";\n           end if;\n" );
	}
	bufVhdl.append("      when others => etat_suivant <= state_");
	bufVhdl.append(fsm.statesNames.get(0));
	bufVhdl.append(";\n    end case;\nend process;\n");
	bufVhdl.append("------------------ NON MEMORIZED OUTPUTS ------------\n"); 

	for (int n=0;n<fsm.outputsNames.size();n++)
	{
		String currentOutputName=fsm.outputsNames.get(n);
		bufVhdl.append("looking for ");	
		bufVhdl.append(currentOutputName);
		bufVhdl.append("\n");	

		//look for actions in the fsm that deals with this output

		for (int m=0;m<fsm.statesNames.size();m++)
		{
			bufVhdl.append("in ");	
			bufVhdl.append(fsm.statesNames.get(m));
			bufVhdl.append("\n");	


			//action on state
//		 	if  ( fsm.states.get(m).attachedActions.actions.size()!=0)
//			{
//				// Action a=fsm.states.get(m).attachedActions.getActionFromOutputName(currentOutputName);
//				 //Action a=fsm.states.get(m).attachedActions.actions.get(0);
//				Action a=fsm.states.get(m).attachedActions.getActionFromOutputName("toto");
//				 
//				 // fsm.states.get(fsm.cptStates-1).attachedActions.actions.add(a);
//				//						System.out.print("adding :   ");
//				//	System.out.print(a.name);
//				//	System.out.print(" action to state :   ");
//				//	System.out.print(fsm.states.get(fsm.cptStates-1).name);
//				//	System.out.print(" \n"); 
//				 
//				if (a!=null)
//				{
//					bufVhdl.append("TROUVE\n");	
//				}
//				 else
//					{
//						bufVhdl.append("PAS TROUVE\n");	
//					}		 
//			}
//			else
//			{
//				bufVhdl.append("PAS d'action sur cet état\n");	
//			}
//			 
			//action on transition
		}
//	bufVhdl.append("  <= \'1\' when ");
//	fsm.outputs 


	bufVhdl.append("else ");


		bufVhdl.append("0; \n");		
	}

	/*
	 ts <= (others => '1') when present = et0 or present = et2 or present = et4 else
		(others => '0');
		 */

		bufVhdl.append("------------------ MEMORIZED OUTPUTS ------------\n"); 

		System.out.println(bufVhdl);
	}
	/////////////////////////////////////////////////////////////////
	static class Transition {
		String origin;
		String destination;
		String condition;
		ArrayList<Action> attachedActions=new ArrayList<Action>() ;		
	}
	////////////////////////////////////////////////////////////////////
	static class Action {
		String type;
		String name;
		String expression;
	}
	////////////////////////////////////////////////////////////////////
	static class Input{
		String type;
		String name;
	}
	////////////////////////////////////////////////////////////////////
	static class Output{
		String type;
		String name;
		Boolean memorized;
	}
	////////////////////////////////////////////////////////////////////
	static class State{
		Boolean isInit; //initial state or not
		//	String name=new String("");
		String name;
		//		static ArrayList<Action> attachedActions=new ArrayList<Action>() ;		
		ActionList attachedActions;
		//static ArrayList<Transition> transitionFromThisState=new ArrayList<Transition>() ;		
		TransitionList transitionsFromThisState;


	}
	////////////////////////////////////////////////////////////////////
	static class TransitionList{
		ArrayList<Transition> transitions=new ArrayList<Transition>() ;		
	}
	////////////////////////////////////////////////////////////////////
	static class ActionList{
		ArrayList<Action> actions=new ArrayList<Action>() ;		
		Action getActionFromOutputName(String outputNameToFind)
		{
			/*for (int n=0;n<actions.size();n++)
				if (actions.get(n).name.equals(outputNameToFind))
					return actions.get(n);
			 */
			return null;
		}
	}
	////////////////////////////////////////////////////////////////////
	/*	static class StatesList{
		ArrayList<State> states=new ArrayList<State>() ;	
	}
////////////////////////////////////////////////////////////////////
	static class InputsList{
		ArrayList<Input> inputs=new ArrayList<Input>() ;	
		Boolean containsName(String name)
		{
			for (int n=0;n<inputs.size();n++)
				if (inputs.get(n).name.equals(name))
					return true;
			return false;
		}

	}
////////////////////////////////////////////////////////////////////
	static class OutputsList{
		ArrayList<Output> outputs=new ArrayList<Output>() ;	
	}
////////////////////////////////////////////////////////////////////
	static class TransitionsList{
		ArrayList<Transition> transitions=new ArrayList<Transition>() ;	
	}
	 */
	////////////////////////////////////////////////////////////////////	
	//	doc de ArrayList : 	http://imss-www.upmf-grenoble.fr/prevert/Prog/Java/Conteneurs/ArrayList.html
	//  et 	https://openclassrooms.com/courses/apprenez-a-programmer-en-java/les-collections-d-objets
	/*public class ArrayListWithAccesFromNames<E> extends ArrayList<E>
                        implementsList<E>, RandomAccess, Cloneable, java.io.Serializable{


}
	 */
	//hash map:  http://stackoverflow.com/questions/14836870/java-arraylist-adding-object-using-string-name
	//Map<String, Integer> map = new HashMap<String, Integer>();
	// which will contain the mapping of itemName to respective Item, and then getting the Item for a particular itemName is as simple as map.get(itemName).
	// exemple: http://beginnersbook.com/2013/12/hashmap-in-java-with-example/
	//doc complete: https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html

	////////////////////////////////////////////////////////////////////
	static class FiniteStateMachine{

		public static int cptStates = 0;  
		public static int nbActionsInState;
		public static int nbActionsInTransition;
		public static Boolean inState = false; // set to true when inside a state, false  elsewhere
		public static Boolean inTransition = false; // set to true when inside a transistion,false elsewhere
		public static Boolean transitionIsReset=false;
		public static Boolean inAction = false; // set to true when inside an action, false elsewhere
		public static Boolean conditionDefined;
		public static String currentStateName = null;
		public static String actionType;
		public static String actionName;
		public static String actionExpression;
		public static String conditionName;
		public static String inputName;

		public String name;
		ArrayList<State> states=new ArrayList<State>() ;
		HashMap<String,State > hmapState = new HashMap<String,State>();
		ArrayList<Input> inputs=new ArrayList<Input>() ;
		HashMap<String,Input > hmapInput = new HashMap<String,Input>();
		ArrayList<Output>  outputs=new ArrayList<Output>() ;
		HashMap<String,Output > hmapOutput = new HashMap<String,Output>();
		ArrayList<Transition> transitions=new ArrayList<Transition>() ;
		HashMap<String,Transition > hmapTransition = new HashMap<String,Transition>();
		public State getStateFromName(String name)
		{
			if (!hmapState.containsKey(name))
				return null;
			else
				return hmapState.get(name);
		}
		public boolean addState(String name, State s)
		{
			if  (hmapState.containsKey(name) || hmapState.containsValue(s) )  
				return false;                 //if this  has already been added, return false
			else
			{
				fsm.hmapState.put(name,s);     //else add it to the hash map
				states.add(s);      		   //and to the list
				return true;
			}
		}
		public Input getInputFromName(String name)
		{
			if (!hmapInput.containsKey(name))
				return null;
			else
				return hmapInput.get(name);
		}
		public boolean addInput(String name, Input i)
		{
			if  (hmapInput.containsKey(name) || hmapInput.containsValue(i) ) 
				return false;                //if this has already been added, return false
			else
			{
				fsm.hmapInput.put(name,i);     //else add it to the hash map
				inputs.add(i);      		   //and to the list
				return true;
			}
		}
		public Output getOutputFromName(String name)
		{
			if (!hmapOutput.containsKey(name))
				return null;
			else
				return hmapOutput.get(name);
		}
		public boolean addOutput(String name, Output o)
		{
			if  (hmapOutput.containsKey(name) || hmapOutput.containsValue(o) ) 
				return false;                //if this has already been added, return false
			else
			{
				fsm.hmapOutput.put(name,o);    //else add it to the hash map
				outputs.add(o);      		   //and to the list
				return true;
			}
		}
		public Transition getTransitionFromName(String name)
		{
			if (!hmapTransition.containsKey(name))
				return null;
			else
				return hmapTransition.get(name);
		}
		public boolean addTransition(String name, Transition t)
		{
			if  (hmapTransition.containsKey(name) || hmapTransition.containsValue(t) ) 
				return false;                //if this has already been added, return false
			else
			{
				fsm.hmapTransition.put(name,t);    //else add it to the hash map
				transitions.add(t);      		   //and to the list
				return true;
			}
		}





	}
	/////////////////////////////////////////////////////////////////
	//	Il suffit de redéfinir la méthode equals de tes objets pour contrôler comment fonctionne le contains (c'est lui qui est appelé pour faire la comparaison). 

	/////////////////////////////////////////////////////////////////
	/*static class Graph {
		// I'm using org.antlr.v4.runtime.misc: OrderedHashSet, MultiMap
		Set<String> nodes = new OrderedHashSet<String>(); // list of functions
		MultiMap<String, String> edges = // caller->callee
		new MultiMap<String, String>();

		public void edge(String source, String target) {
			edges.map(source, target);
		}

		public String toString() {
			return "edges: " + edges.toString() + ", functions: " + nodes;
		}
	 }
	 */
	/////////////////////////////////////////////////////////////////
	static class FunctionListener extends FsmBaseListener {
		//Graph graph = new Graph();
		// String currentFunctionName = null;

		////////////////////////////////////////////////////////////////
		public void enterInput(FsmParser.InputContext ctx){
			fsm.inputName = ctx.children.get(0).getText();
			Input i=new Input();
			i.name=fsm.inputName ;
			fsm.addInput(fsm.inputName, i);
			//TODO:	
			/*
		 	if (! fsm.inputs.containsName(fsm.inputName))
				fsm.inputs.add(fsm.inputName);			
			 */
		}
		////////////////////////////////////////////////////////////////
		public void exitInput(FsmParser.InputContext ctx){

		}
		////////////////////////////////////////////////////////////////

		////////////////////////////////////////////////////////////////
		public void  enterFsm_name(FsmParser.Fsm_nameContext ctx){
			fsm.name=ctx.getText();
			bufDot.append("// Finite State Machine Name: ");
			bufDot.append(fsm.name);
			bufDot.append("\n");
			bufDot.append("///////////////////////////////////////////////////////////////////////////////////////////////////////////\n");
		}
		////////////////////////////////////////////////////////////////
		public void enterReset_transition(FsmParser.Reset_transitionContext ctx)
		{			
			fsm.transitionIsReset=true;
			fsm.inTransition = true;
			fsm.conditionDefined=false;
			fsm.conditionName="1"; //default
			fsm.nbActionsInTransition=0;
			bufDot.append("    	node [shape=box] ");
			bufDot.append("    	emptystateforreset");
			bufDot.append(fsm.currentStateName);
			bufDot.append("[shape=box, style=\"invis\" ];\n");
			bufDot.append("    	emptystateforreset");
			bufDot.append(fsm.currentStateName);
			bufDot.append(" -> ");
			bufDot.append(ctx.children.get(1).getText());
		}
		////////////////////////////////////////////////////////////////		
		public 	void exitReset_transition(FsmParser.Reset_transitionContext ctx)
		{
			fsm.inTransition = false;
			if (fsm.nbActionsInTransition==0) //the table and condition have not yet been generated by the first action
			{
				bufDot.append("[style=\"dashed\", shape=box, label=  <<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> <TR>   <TD COLSPAN=\"1\">");
				bufDot.append(fsm.conditionName);
				bufDot.append("</TD> </TR>");
			}
			bufDot.append("  </TABLE>>  ];\n");	
			//TODO ajouter une transition à la liste avec org=NULL
		}
		////////////////////////////////////////////////////////////////
		public void  enterCondition(FsmParser.ConditionContext ctx){
			fsm.conditionDefined=true;
			//ca vire les espaces
			//fsm.conditionName=ctx.getText();
			//System.out.println("fsm.conditionName:");
			//System.out.println(fsm.conditionName);
			fsm.conditionName="";
			int nbChildren= ctx.getChildCount();
			for (int n=0;n<nbChildren;n++)
			{
				fsm.conditionName+=ctx.children.get(n).getText();
				if (n!=nbChildren-1)
					fsm.conditionName+=" ";
			}

			//TODO:
			//fsm.transitions.get(fsm.transitions.size()-1).condition=fsm.conditionName;

		}
		////////////////////////////////////////////////////////////////
		public 	void exitCondition(FsmParser.ConditionContext ctx){
		}
		////////////////////////////////////////////////////////////////
		public void enterTransition(FsmParser.TransitionContext ctx) {
			fsm.transitionIsReset=false;
			fsm.inTransition = true;
			fsm.conditionDefined=false;
			fsm.conditionName="1"; //default
			fsm.nbActionsInTransition=0;

			//TODO:
			/*fsm.transitions.transitions.add(new Transition());
			fsm.transitions.transitions.get(fsm.transitions.transitions.size()-1).origin=ctx.children.get(0).getText();
			fsm.transitions.transitions.get(fsm.transitions.transitions.size()-1).destination=ctx.children.get(2).getText();
			 */	
			bufDot.append("    	");
			bufDot.append(ctx.children.get(0).getText());
			bufDot.append(" -> ");
			bufDot.append(ctx.children.get(2).getText());
		}
		////////////////////////////////////////////////////////////////
		public void exitTransition(FsmParser.TransitionContext ctx) {
			fsm.inTransition = false;
			if (fsm.nbActionsInTransition==0) //the table and condition have not yet been generated by the first action
			{
				bufDot.append("[shape=box, label=  <<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> <TR>   <TD COLSPAN=\"1\">");
				bufDot.append(fsm.conditionName);
				bufDot.append("</TD> </TR>");
			}
			bufDot.append("  </TABLE>>  ];\n");

			//fsm.nbTransitions++;
		}
		////////////////////////////////////////////////////////////////
		public void enterAction_expression(FsmParser.Action_expressionContext ctx) {
			if (fsm.inState || fsm.inTransition) {
				fsm.actionExpression = ctx.children.get(0).getText();
				//TODO IL FAUT COMPLETER CAR ICI JE NE GERE QUE LE 1° TERME...
			}
		}	
		////////////////////////////////////////////////////////////////
		public void exitAction_expression(FsmParser.Action_expressionContext ctx) {
		}
		////////////////////////////////////////////////////////////////
		public void enterAction_id(FsmParser.Action_idContext ctx) {
			if (fsm.inState || fsm.inTransition )
			{
				fsm.actionName = ctx.children.get(0).getText();
				//TODO:
				/*				if (! fsm.outputs.containsName(fsm.actionName))
					fsm.outputs.add(fsm.actionName);
				 */
			}
		}
		////////////////////////////////////////////////////////////////
		public void exitAction_id(FsmParser.Action_idContext ctx) {
		}
		////////////////////////////////////////////////////////////////
		public void enterAction_type(FsmParser.Action_typeContext ctx) {
			fsm.actionType = ctx.children.get(0).getText();
		}
		////////////////////////////////////////////////////////////////
		public void exitAction_type(FsmParser.Action_typeContext ctx) {
		}
		////////////////////////////////////////////////////////////////
		public void enterAction(FsmParser.ActionContext ctx) {
			fsm.actionType = "I"; // default value if not specified
			fsm.actionName = "";
			fsm.actionExpression = "";
			fsm.transitionIsReset = true; 
			if (fsm.inState) { 
				fsm.nbActionsInState++;
				if (fsm.nbActionsInState == 1) {
					bufDot.append("//Action on state:\n");
					bufDot.append("    	stateaction");
					bufDot.append(fsm.currentStateName);
					bufDot.append("  [shape=box,label=  ");
					bufDot.append(" <<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\">\n");
				}
			}
			else if (fsm.inTransition) { 
				fsm.nbActionsInTransition++;
				if (fsm.nbActionsInTransition == 1) 
				{ 
					bufDot.append("[");
					if (fsm.transitionIsReset==true)
						bufDot.append(" style=\"dashed\", ");
					bufDot.append("shape=box, label=  <<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> <TR>   <TD COLSPAN=\"2\">");
					bufDot.append(fsm.conditionName);
					bufDot.append("</TD> </TR>");
				}				
			}
		}
		////////////////////////////////////////////////////////////////
		public void exitAction(FsmParser.ActionContext ctx) {
			fsm.transitionIsReset = false;
			if (fsm.inState || fsm.inTransition) 
			{
				bufDot.append("<TR><TD>");
				bufDot.append(fsm.actionType);
				bufDot.append("</TD><TD>");
				bufDot.append(fsm.actionName);
				if (fsm.actionExpression != "") 
				{
					bufDot.append("=");
					bufDot.append(fsm.actionExpression);
				}
				bufDot.append("</TD> </TR>");
			}

		}	
		////////////////////////////////////////////////////////////////
		public void enterState(FsmParser.StateContext ctx) {
			fsm.cptStates++;
			fsm.inState = true;
			bufDot.append("    	");
			fsm.currentStateName = ctx.children.get(0).getText();
			bufDot.append(fsm.currentStateName);
			if (fsm.cptStates == 1)
				bufDot.append(" [shape=doublecircle];\n");
			else
				bufDot.append(" [shape=circle];\n");
			fsm.nbActionsInState = 0;
			//TODO:	
			//	if (! fsm.states.containsName(fsm.currentStateName))
			if (true)
			{
				//				fsm.states.states.add(fsm.currentStateName);	
				State s=new State();
				s.name=fsm.currentStateName;
				if (fsm.cptStates==1)
					s.isInit=true;
				else
					s.isInit=false;
				//TODO:
				//	fsm.states.states.add(s);
				Action a=new Action();
				a.expression="blabla";
				a.name="toto";
				a.type="I";
				//fsm.states.get(fsm.cptStates-1).attachedActions.actions.add(a);


				/*
				System.out.print("adding :   ");
				System.out.print(a.name);
				System.out.print(" action to state :   ");
				System.out.print(fsm.states.get(fsm.cptStates-1).name);
				System.out.print(" \n");
				 */
			}
			// is there some action on this states
			/*
			 * int nbChildren= ctx.getChildCount();
			 * System.out.print("nbChildren:   ");
			 * System.out.println(nbChildren); for (int i=0;i<nbChildren;i++) {
			 * System.out.print(ctx.children.get(i).getText());
			 * System.out.print("   "); }
			 * System.out.println(ctx.getText());
			 */
		}
		/////////////////////////////////////////////////////////////////
		public void exitState(FsmParser.StateContext ctx) {
			// System.out.println("exit state");
			fsm.inState = false;
			if (fsm.nbActionsInState != 0) 
			{
				bufDot.append("</TABLE>>  ];\n");
				bufDot.append("//attach the action on the state\n    	");
				bufDot.append(fsm.currentStateName);
				bufDot.append(" ->");
				bufDot.append("stateaction");
				bufDot.append(fsm.currentStateName);
				bufDot.append("  [arrowhead=none]     ;\n");
			}
		}
		/////////////////////////////////////////////////////////////////
	}
	/////////////////////////////////////////////////////////////////
	public static void main(String[] args) throws Exception {
		String inputFile = null;
		if (args.length > 0)
			inputFile = args[0];
		InputStream is = System.in;
		if (inputFile != null) {
			is = new FileInputStream(inputFile);
		}
		ANTLRInputStream input = new ANTLRInputStream(is);
		FsmLexer lexer = new FsmLexer(input);
		CommonTokenStream tokens = new CommonTokenStream(lexer);
		FsmParser parser = new FsmParser(tokens);
		parser.setBuildParseTree(true);
		ParseTree tree = parser.file();

		// show tree in text form
		// System.out.println(tree.toStringTree(parser));

		ParseTreeWalker walker = new ParseTreeWalker();
		FunctionListener collector = new FunctionListener();
		bufVhdl = new StringBuilder();

		bufDot = new StringBuilder();
		bufDot.append("///////////////////////////////////////////////////////////////////////////////////////////////////////////\n");
		bufDot.append("// Finite State Machine .dot diagram autogenerated by FsmProcess B. VANDEPORTAELE LAAS/CNRS 2016\n");
		bufDot.append("///////////////////////////////////////////////////////////////////////////////////////////////////////////\n");
		bufDot.append("digraph finite_state_machine {\n");
		bufDot.append("    	rankdir=LR;\n");
		bufDot.append("    	size=\"10\";\n");
		bufDot.append("///////////////////////////////////////////////////////////////////////////////////////////////////////////\n");
		walker.walk(collector, tree);
		// pour affichage en chaine
		// System.out.println(collector.graph.toString());
		// pour affichage en .DOT
		// System.out.println(collector.graph.toDOT());

		// Here's another example that uses StringTemplate to generate output
		// System.out.println(collector.graph.toST().render());



		bufDot.append("}\n");
		System.out.println(bufDot.toString());

		generateVhdl();
		//System.out.println(bufVhdl);

		/*
		System.out.println("Liste des actions");
		for (int n=0;n<outputList.size();n++)
			System.out.println(outputList.get(n));
		System.out.println("Liste des entrées");
		for (int n=0;n<inputList.size();n++)
			System.out.println(inputList.get(n));
		 */
	}
}
