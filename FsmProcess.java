/***
 * Excerpted from "The Definitive ANTLR 4 Reference",
 * published by The Pragmatic Bookshelf.
 * Copyrights apply to this code. It may not be used to create training material, 
 * courses, books, articles, and the like. Contact us if you are in doubt.
 * We make no guarantees that this code is fit for any purpose. 
 * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information.
 ***/
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.misc.MultiMap;
import org.antlr.v4.runtime.misc.OrderedHashSet;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;

import java.io.FileInputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Set;

import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;



//TODO: comprendre pourquoi antlr ne genere par le fichier FsmParser.java  mais uniquement le class...

public class FsmProcess {

	static StringBuilder bufDot;
	static StringBuilder bufVhdl;	
	static FiniteStateMachine fsm=new FiniteStateMachine();

	//////////////////////////////////////////////////
	static public void generateDot()
	{
		bufDot.append("///////////////////////////////////////////////////////////////////////////////////////////////////////////\n");
		bufDot.append("// Finite State Machine .dot diagram autogenerated by FsmProcess B. VANDEPORTAELE LAAS/CNRS 2016\n");
		bufDot.append("///////////////////////////////////////////////////////////////////////////////////////////////////////////\n");
		bufDot.append("digraph finite_state_machine {\n");
		bufDot.append("    	rankdir=LR;\n");
		bufDot.append("    	size=\"10\";\n");
		bufDot.append("///////////////////////////////////////////////////////////////////////////////////////////////////////////\n");
		bufDot.append("// Finite State Machine Name: ");
		bufDot.append(fsm.name);
		bufDot.append("\n");
		bufDot.append("///////////////////////////////////////////////////////////////////////////////////////////////////////////\n");
		bufDot.append("//////////////////display  states//////////////////\n");
		for (int n=0;n<fsm.states.size();n++)
		{
			//add states to the dot file
			bufDot.append("    	//State:\n");
			bufDot.append("    	");
			bufDot.append(fsm.states.get(n).name);
			if (fsm.states.get(n).isInit)
				bufDot.append(" [shape=doublecircle];\n");
			else
				bufDot.append(" [shape=circle];\n");
			//add actions states to the dot file if necessary
			int nbAttachedActions=fsm.states.get(n).attachedActions.size();
			if (nbAttachedActions!= 0) 
			{
				bufDot.append("    	//Action on state:\n");
				bufDot.append("    	stateaction");
				bufDot.append(fsm.states.get(n).name);
				bufDot.append("  [shape=box,label=  ");
				bufDot.append(" <<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\">\n");
				for (int m=0;m<nbAttachedActions;m++)
				{
					bufDot.append("    	    	<TR><TD>");
					bufDot.append(fsm.states.get(n).attachedActions.get(m).type);
					bufDot.append("</TD><TD>");
					bufDot.append(fsm.states.get(n).attachedActions.get(m).name);
					if (fsm.states.get(n).attachedActions.get(m).expression!= "") 
					{
						bufDot.append("=");
						bufDot.append(fsm.states.get(n).attachedActions.get(m).expression);
					}
					bufDot.append("</TD> </TR>\n");
				}
				bufDot.append("    	    	</TABLE>>  ];\n");
				bufDot.append("    	//attach the action on the state\n    	");
				bufDot.append(fsm.states.get(n).name);
				bufDot.append(" ->");
				bufDot.append("stateaction");
				bufDot.append(fsm.states.get(n).name);
				bufDot.append("  [arrowhead=none]     ;\n");
			}
		}
		bufDot.append("//////////////////display  transitions//////////////////\n");
		for (int n=0;n<fsm.states.size();n++)
		{
			int nbTransitions=fsm.states.get(n).transitionsFromThisState.size();
			if (nbTransitions!= 0) 
				for (int m=0;m<nbTransitions;m++)
				{
					Transition t=fsm.states.get(n).transitionsFromThisState.get(m);
					bufDot.append("    	");
					bufDot.append(t.origin);
					bufDot.append(" -> ");
					bufDot.append(t.destination);
					bufDot.append("[shape=box, label=  <<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\">\n");
					bufDot.append("    	    	<TR>   <TD COLSPAN=\"");
					int nbActionsInTransitions=t.attachedActions.size();
					if (nbActionsInTransitions==0)
						bufDot.append("1");
					else
						bufDot.append("2");
					bufDot.append("\">");
					bufDot.append(t.condition);
					bufDot.append("</TD> </TR>\n");
					for (int l=0;l<nbActionsInTransitions;l++)
					{
						bufDot.append("    	    	<TR><TD>");
						bufDot.append(t.attachedActions.get(l).type);
						bufDot.append("</TD><TD>");
						bufDot.append(t.attachedActions.get(l).name);
						if (t.attachedActions.size()!=0)
							if (! t.attachedActions.get(l).expression.equals(""))
							{
								bufDot.append("=");
								bufDot.append(t.attachedActions.get(l).expression);
							}
						bufDot.append("</TD> </TR>\n");
					}
					bufDot.append("    	    	</TABLE>>  ];\n");

				}
		}
		bufDot.append("//////////////////display reset transitions//////////////////\n");
		for (int k=0;k<fsm.resetTransitions.size();k++)
		{
			ResetTransition rt=fsm.resetTransitions.get(k);
			//bufDot.append("    	node [shape=box] ");
			bufDot.append("    	emptystateforreset");
		 	bufDot.append(k); //generate a name from the k value
			bufDot.append(" [shape=box, style=\"invis\" ];\n");
			bufDot.append("    	emptystateforreset");
		 	bufDot.append(k);
			bufDot.append(" -> ");
			bufDot.append(rt.destination);
			bufDot.append("  ");
			bufDot.append("[style=\"dashed\", shape=box, label=  <<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\">\n");
			bufDot.append("    	    	<TR>   <TD COLSPAN=\"");
			int nbActionsInResetTransitions=rt.attachedActions.size();
			if (nbActionsInResetTransitions==0)
				bufDot.append("1");
			else
				bufDot.append("2");
			bufDot.append("\">");
			bufDot.append(rt.condition);
			bufDot.append("</TD> </TR>\n");
			for (int l=0;l<nbActionsInResetTransitions;l++)
			{
				bufDot.append("    	    	<TR><TD>");
				bufDot.append(rt.attachedActions.get(l).type);
				bufDot.append("</TD><TD>");
				bufDot.append(rt.attachedActions.get(l).name);
				if (rt.attachedActions.size()!=0)
					if (! rt.attachedActions.get(l).expression.equals(""))
					{
						bufDot.append("=");
						bufDot.append(rt.attachedActions.get(l).expression);
					}
				bufDot.append("</TD> </TR>\n");
			} 
			bufDot.append("    	    	</TABLE>>  ];\n");	
		}
		bufDot.append("}\n");
	}
	//////////////////////////////////////////////////
	static public void generateVhdl()
	{
		bufVhdl.append("--/////////////////////////////////////////////////////////////////////////////////////////////////////////\n");
		bufVhdl.append("-- Finite State Machine .vhdl  autogenerated by FsmProcess B. VANDEPORTAELE LAAS/CNRS 2016\n");
		bufVhdl.append("--/////////////////////////////////////////////////////////////////////////////////////////////////////////\n");
		bufVhdl.append("library	ieee;\nuse		ieee.std_logic_1164.all;\nuse		ieee.std_logic_unsigned.all;\nuse		ieee.std_logic_arith.all;\nentity ");
		bufVhdl.append(fsm.name);
		bufVhdl.append(" is\n	port (\n");
		bufVhdl.append("		ck,arazb								: in  std_logic;\n");

		/*
State s0=new State();
State s1=new State();
State s2=new State();
s0.isInit=true;
s1.isInit=false;
s2.isInit=false;
s0.name="0";
s1.name="1";
s2.name="2";
fsm.hmapState.put("etat0",s0);
fsm.hmapState.put("etat2",s2);
fsm.hmapState.put("etat1",s1);
bufVhdl.append("nb elements: ");
bufVhdl.append(fsm.hmapState.size());
bufVhdl.append("\n");
State s=fsm.getStateFromName("etat0");
if (s!=null)
	{
	bufVhdl.append("etat1: ");
	bufVhdl.append(s.isInit);
	bufVhdl.append("\n");
	}
if (!fsm.addState("etat3",s0))
	bufVhdl.append("premier essai raté\n ");
if (!fsm.addState("etat3",s0))
	bufVhdl.append("second essai raté\n ");
fsm.addState("etat4",s0);
		 */



		for (int n=0;n<fsm.hmapInput.size();n++)
		{
			bufVhdl.append("		");
			bufVhdl.append(fsm.inputs.get(n).name);
			bufVhdl.append(": in  std_logic;\n");
		}
	 
	for (int n=0;n<fsm.hmapOutput.size();n++)
	{
	bufVhdl.append("		");
	bufVhdl.append(fsm.outputs.get(n).name);
	bufVhdl.append(": out  std_logic");
	if (n!=fsm.hmapOutput.size()-1)
		bufVhdl.append(";\n");
	else	
		bufVhdl.append(");\n");		
	}

	bufVhdl.append("end ");	
	bufVhdl.append(fsm.name);
	bufVhdl.append(";\n\n");
	bufVhdl.append("architecture a of ");
	bufVhdl.append(fsm.name);
	bufVhdl.append(" is \n");
	bufVhdl.append("type fsm_state is (");
	
	for (int n=0;n<fsm.states.size();n++)
	{
		//prefix state name with state_
		bufVhdl.append("state_");
		bufVhdl.append(fsm.states.get(n).name);
		if (n!=fsm.states.size()-1)
			bufVhdl.append(", ");
	}
	bufVhdl.append(");\n");
	bufVhdl.append("signal etat_present, etat_suivant : etat_mae;\n");

	bufVhdl.append("begin\n");
	bufVhdl.append("process (ck, arazb)\nbegin\n    if (arazb='0') then etat_present <=");
	bufVhdl.append("state_");
	bufVhdl.append(fsm.states.get(0).name);
	bufVhdl.append(";\n");
	bufVhdl.append("    elsif ck'event and ck='1' then etat_present<=etat_suivant;\n");
	bufVhdl.append("    end if;\n");
	bufVhdl.append("end process;\n\n");

	bufVhdl.append("process (etat_present");
	for (int n=0;n<fsm.inputs.size();n++)
	{
		bufVhdl.append(", ");
		bufVhdl.append(fsm.inputs.get(n).name);
	}
	bufVhdl.append(")\nbegin\n");
	bufVhdl.append("    case etat_present is\n");
	//pour chaque état, il peut y avoir plusieurs transitions, la première if, les suivantes elsif et finalement en plus le maintien dans l'état courant
	int numberOfStates=fsm.states.size();
	for (int n=0;n<numberOfStates;n++)
 	{
		bufVhdl.append("      when state_");	//prefix state name with state_
		bufVhdl.append(fsm.states.get(n).name);
		int transitionFromThisStateNumber=fsm.states.get(n).transitionsFromThisState.size();
		bufVhdl.append(" => ");
		//if (transitionFromThisStateNumber==0) //stay always in that state
		for (int m=0;m<transitionFromThisStateNumber;m++)
		{
			if (m==0)
				bufVhdl.append("   if ( ");
			else
				bufVhdl.append("                         elsif ( ");
			bufVhdl.append(fsm.states.get(n).transitionsFromThisState.get(m).condition);
			bufVhdl.append(" ) then etat_suivant <= state_");
			bufVhdl.append(fsm.states.get(n).transitionsFromThisState.get(m).destination);
			bufVhdl.append(";\n");
		}
		if (transitionFromThisStateNumber!=0)
			bufVhdl.append("                         else	");
		bufVhdl.append("etat_suivant <= state_");
		bufVhdl.append(fsm.states.get(n).name);
		bufVhdl.append(";\n           end if;\n" );
 	}
	bufVhdl.append("      when others => etat_suivant <= state_");
	bufVhdl.append(fsm.states.get(0).name);
	bufVhdl.append(";\n    end case;\nend process;\n");
	bufVhdl.append("------------------ NON MEMORIZED OUTPUTS ------------\n"); 
/*
	for (int n=0;n<fsm.outputs.size();n++)
	{
		String currentOutputName=fsm.outputs.get(n).name;
		bufVhdl.append("looking for ");	
		bufVhdl.append(currentOutputName);
		bufVhdl.append("\n");	

		//look for actions in the fsm that deals with this output

		for (int m=0;m<fsm.states.size();m++)
		{
			bufVhdl.append("in ");	
			bufVhdl.append(fsm.states.get(m).name);
			bufVhdl.append("\n");	


			//action on state
//		 	if  ( fsm.states.get(m).attachedActions.actions.size()!=0)
//			{
//				// Action a=fsm.states.get(m).attachedActions.getActionFromOutputName(currentOutputName);
//				 //Action a=fsm.states.get(m).attachedActions.actions.get(0);
//				Action a=fsm.states.get(m).attachedActions.getActionFromOutputName("toto");
//				 
//				 // fsm.states.get(fsm.cptStates-1).attachedActions.actions.add(a);
//				//						System.out.print("adding :   ");
//				//	System.out.print(a.name);
//				//	System.out.print(" action to state :   ");
//				//	System.out.print(fsm.states.get(fsm.cptStates-1).name);
//				//	System.out.print(" \n"); 
//				 
//				if (a!=null)
//				{
//					bufVhdl.append("TROUVE\n");	
//				}
//				 else
//					{
//						bufVhdl.append("PAS TROUVE\n");	
//					}		 
//			}
//			else
//			{
//				bufVhdl.append("PAS d'action sur cet état\n");	
//			}
//			 
			//action on transition
		}
//	bufVhdl.append("  <= \'1\' when ");
//	fsm.outputs 


	bufVhdl.append("else ");


		bufVhdl.append("0; \n");		
	}

	/*
	 ts <= (others => '1') when present = et0 or present = et2 or present = et4 else
		(others => '0');
		 */

		bufVhdl.append("------------------ MEMORIZED OUTPUTS ------------\n"); 

		System.out.println(bufVhdl);
	}
	/////////////////////////////////////////////////////////////////
	static class ResetTransition {
		String destination;
		String condition;
		ArrayList<Action> attachedActions=new ArrayList<Action>() ;		
	}	/////////////////////////////////////////////////////////////////
	static class Transition {
		String origin;
		String destination;
		String condition;
		ArrayList<Action> attachedActions=new ArrayList<Action>() ;		
	}
	////////////////////////////////////////////////////////////////////
	static class Action {
		String type;
		String name;
		String expression;
	}
	////////////////////////////////////////////////////////////////////
	static class Input{
		String type;
		String name;
	}
	////////////////////////////////////////////////////////////////////
	static class Output{
		String type;
		String name;
		Boolean memorized;
	}
	////////////////////////////////////////////////////////////////////
	static class State{
		Boolean isInit; //initial state or not
		//	String name=new String("");
		String name;
		//		static ArrayList<Action> attachedActions=new ArrayList<Action>() ;		
		ArrayList<Action>  attachedActions=new ArrayList<Action>() ;	
		//static ArrayList<Transition> transitionFromThisState=new ArrayList<Transition>() ;		
		ArrayList<Transition>  transitionsFromThisState=new ArrayList<Transition>() ;	
	}
	////////////////////////////////////////////////////////////////////
	/*static class TransitionList{
		ArrayList<Transition> transitions=new ArrayList<Transition>() ;		
	}
	////////////////////////////////////////////////////////////////////
	static class ActionList{
		ArrayList<Action> actions=new ArrayList<Action>() ;		
		Action getActionFromOutputName(String outputNameToFind)
		{
			//for (int n=0;n<actions.size();n++)
			//	if (actions.get(n).name.equals(outputNameToFind))
			//		return actions.get(n);

			return null;
		}
	}*/
	////////////////////////////////////////////////////////////////////
	/*	static class StatesList{
		ArrayList<State> states=new ArrayList<State>() ;	
	}
////////////////////////////////////////////////////////////////////
	static class InputsList{
		ArrayList<Input> inputs=new ArrayList<Input>() ;	
		Boolean containsName(String name)
		{
			for (int n=0;n<inputs.size();n++)
				if (inputs.get(n).name.equals(name))
					return true;
			return false;
		}

	}
////////////////////////////////////////////////////////////////////
	static class OutputsList{
		ArrayList<Output> outputs=new ArrayList<Output>() ;	
	}
////////////////////////////////////////////////////////////////////
	static class TransitionsList{
		ArrayList<Transition> transitions=new ArrayList<Transition>() ;	
	}
	 */
	////////////////////////////////////////////////////////////////////	
	//	doc de ArrayList : 	http://imss-www.upmf-grenoble.fr/prevert/Prog/Java/Conteneurs/ArrayList.html
	//  et 	https://openclassrooms.com/courses/apprenez-a-programmer-en-java/les-collections-d-objets
	/*public class ArrayListWithAccesFromNames<E> extends ArrayList<E>
                        implementsList<E>, RandomAccess, Cloneable, java.io.Serializable{


}
	 */
	//hash map:  http://stackoverflow.com/questions/14836870/java-arraylist-adding-object-using-string-name
	//Map<String, Integer> map = new HashMap<String, Integer>();
	// which will contain the mapping of itemName to respective Item, and then getting the Item for a particular itemName is as simple as map.get(itemName).
	// exemple: http://beginnersbook.com/2013/12/hashmap-in-java-with-example/
	//doc complete: https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html

	////////////////////////////////////////////////////////////////////
	static class FiniteStateMachine{
		//member variables for storing the fsm model
		public String name;
		ArrayList<ResetTransition> resetTransitions=new ArrayList<ResetTransition>() ;
		ArrayList<State> states=new ArrayList<State>() ;
		HashMap<String,State > hmapState = new HashMap<String,State>();
		ArrayList<Input> inputs=new ArrayList<Input>() ;
		HashMap<String,Input > hmapInput = new HashMap<String,Input>();
		ArrayList<Output>  outputs=new ArrayList<Output>() ;
		HashMap<String,Output > hmapOutput = new HashMap<String,Output>();
		ArrayList<Transition> transitions=new ArrayList<Transition>() ;
		HashMap<String,Transition > hmapTransition = new HashMap<String,Transition>();

		//member variables for parsing
		public static State currentState = null;
		public static Action currentAction= null;
		public static Transition currentTransition= null;
		public static ResetTransition currentResetTransition= null;
		public static boolean currentTransitionIsReset; //to know when parsing a condition if it should be added to ResetTransition or Transition		
		//public static int cptStates = 0;   
		//		public static Boolean inState = false; // set to true when inside a state, false  elsewhere
		//		public static Boolean inTransition = false; // set to true when inside a transistion,false elsewhere
		//		public static Boolean transitionIsReset=false;
		//		public static Boolean inAction = false; // set to true when inside an action, false elsewhere
		//		public static Boolean conditionDefined;
		//		public static String currentStateName = null;


		public State getStateFromName(String name)
		{
			if (!hmapState.containsKey(name))
				return null;
			else
				return hmapState.get(name);
		}
		public boolean addState(String name, State s)
		{
			if  (hmapState.containsKey(name) || hmapState.containsValue(s) )  
				return false;                 //if this  has already been added, return false
			else
			{
				fsm.hmapState.put(name,s);     //else add it to the hash map
				states.add(s);      		   //and to the list
				return true;
			}
		}
		public Input getInputFromName(String name)
		{
			if (!hmapInput.containsKey(name))
				return null;
			else
				return hmapInput.get(name);
		}
		public boolean addInput(String name, Input i)
		{
			if  (hmapInput.containsKey(name) || hmapInput.containsValue(i) ) 
				return false;                //if this has already been added, return false
			else
			{
				fsm.hmapInput.put(name,i);     //else add it to the hash map
				inputs.add(i);      		   //and to the list
				return true;
			}
		}
		public Output getOutputFromName(String name)
		{
			if (!hmapOutput.containsKey(name))
				return null;
			else
				return hmapOutput.get(name);
		}
		public boolean addOutput(String name, Output o)
		{
			if  (hmapOutput.containsKey(name) || hmapOutput.containsValue(o) ) 
				return false;                //if this has already been added, return false
			else
			{
				fsm.hmapOutput.put(name,o);    //else add it to the hash map
				outputs.add(o);      		   //and to the list
				return true;
			}
		}
		public Transition getTransitionFromName(String name)
		{
			if (!hmapTransition.containsKey(name))
				return null;
			else
				return hmapTransition.get(name);
		}
		public boolean addTransition(String name, Transition t)
		{
			if  (hmapTransition.containsKey(name) || hmapTransition.containsValue(t) ) 
				return false;                //if this has already been added, return false
			else
			{
				fsm.hmapTransition.put(name,t);    //else add it to the hash map
				transitions.add(t);      		   //and to the list
				return true;
			}
		}
	}
	/////////////////////////////////////////////////////////////////
	//	Il suffit de redéfinir la méthode equals de tes objets pour contrôler comment fonctionne le contains (c'est lui qui est appelé pour faire la comparaison). 

	/////////////////////////////////////////////////////////////////
	/*static class Graph {
		// I'm using org.antlr.v4.runtime.misc: OrderedHashSet, MultiMap
		Set<String> nodes = new OrderedHashSet<String>(); // list of functions
		MultiMap<String, String> edges = // caller->callee
		new MultiMap<String, String>();

		public void edge(String source, String target) {
			edges.map(source, target);
		}

		public String toString() {
			return "edges: " + edges.toString() + ", functions: " + nodes;
		}
	 }
	 */
	/////////////////////////////////////////////////////////////////
	static class FunctionListener extends FsmBaseListener {
		////////////////////////////////////////////////////////////////
		public void enterInput(FsmParser.InputContext ctx){ 
			Input i=new Input();
			i.name=ctx.children.get(0).getText() ;
			fsm.addInput(ctx.children.get(0).getText(), i);
			//TODO:	
			/*
		 	if (! fsm.inputs.containsName(fsm.inputName))
				fsm.inputs.add(fsm.inputName);			
			 */
		}
		////////////////////////////////////////////////////////////////
		public void  enterFsm_name(FsmParser.Fsm_nameContext ctx){
			fsm.name=ctx.getText();
		}
		////////////////////////////////////////////////////////////////
		public void enterReset_transition(FsmParser.Reset_transitionContext ctx)
		{			
			fsm.currentTransitionIsReset=true; 
			ResetTransition rt=new ResetTransition();
			fsm.currentResetTransition=rt;
			rt.condition="1"; //default condition
			rt.destination=ctx.children.get(1).getText();
			fsm.resetTransitions.add(rt);
		}
		////////////////////////////////////////////////////////////////
		public void  enterCondition(FsmParser.ConditionContext ctx){ 
			String reconstructedCondition=new String("");
			int nbChildren= ctx.getChildCount();
			for (int n=0;n<nbChildren;n++) //reconstruct the condition, adding space characters between terms.
			{
				reconstructedCondition+=ctx.children.get(n).getText();
				if (n!=nbChildren-1)
					reconstructedCondition+=" ";
			}
			//put the condition at the right place in the fsm
			if (fsm.currentTransitionIsReset)
				fsm.currentResetTransition.condition=reconstructedCondition;
			else
				fsm.currentTransition.condition=reconstructedCondition;
			//TODO:
			//fsm.transitions.get(fsm.transitions.size()-1).condition=fsm.conditionName;
		} 
		////////////////////////////////////////////////////////////////
		public void enterTransition(FsmParser.TransitionContext ctx) {
			fsm.currentTransitionIsReset=false;
			Transition t=new Transition();
			t.condition="1"; //default
			fsm.currentTransition=t;
			t.origin=ctx.children.get(0).getText();
			t.destination=ctx.children.get(2).getText(); 
			//add the transition in its origin state, first get the state from its name
			if (fsm.hmapState.get(t.origin)!=null) //the state exists
				fsm.hmapState.get(t.origin).transitionsFromThisState.add(t);
			else
			{
				//TODO: deal with this error
			}
		}
		////////////////////////////////////////////////////////////////
		public void enterAction_expression(FsmParser.Action_expressionContext ctx) {
			fsm.currentAction.expression = ctx.children.get(0).getText();
			//TODO: IL FAUT COMPLETER CAR ICI JE NE GERE QUE LE 1° TERME...
		}	
		////////////////////////////////////////////////////////////////
		public void enterAction_id(FsmParser.Action_idContext ctx) { 
			fsm.currentAction.name = ctx.children.get(0).getText();
			
			Output o=new Output();
			o.name=ctx.children.get(0).getText() ;
			//TODO: mettre les autres champs de o, peut être le faire ailleurs
			fsm.addOutput(ctx.children.get(0).getText(), o);
			
			//TODO:
			/*				if (! fsm.outputs.containsName(fsm.actionName))
					fsm.outputs.add(fsm.actionName);
			 */
		}
		////////////////////////////////////////////////////////////////
		public void enterAction_type(FsmParser.Action_typeContext ctx) {
			fsm.currentAction.type= ctx.children.get(0).getText();
		}
		////////////////////////////////////////////////////////////////
		public void enterTransition_action(FsmParser.Transition_actionContext ctx) {
			Action a=new Action();
			fsm.currentAction=a;
			a.type= "I"; // default value if not specified 
			a.name=""; // default value if not specified 
			a.expression=""; // default value if not specified 
			if (!fsm.currentTransitionIsReset)
				fsm.currentTransition.attachedActions.add(a);
			else
				fsm.currentResetTransition.attachedActions.add(a);
		}
		////////////////////////////////////////////////////////////////
		public void enterState_action(FsmParser.State_actionContext ctx) {
			Action a=new Action();
			fsm.currentAction=a;
			a.type= "I"; // default value if not specified 
			a.name=""; // default value if not specified 
			a.expression=""; // default value if not specified 
			fsm.currentState.attachedActions.add(a); 
		}
		////////////////////////////////////////////////////////////////
		public void enterState(FsmParser.StateContext ctx) {
			State s=new State();
			s.name=ctx.children.get(0).getText();
			if (fsm.states.size()==0)
				s.isInit=true;
			else
				s.isInit=false;
			fsm.addState(s.name,s);
			//fsm.states.add(s); 
			fsm.currentState=s;
			//TODO:	
			//	if (! fsm.states.containsName(fsm.currentState.name))
		}
		/////////////////////////////////////////////////////////////////
	}
	/////////////////////////////////////////////////////////////////
	public static void main(String[] args) throws Exception {
		String inputFile = null;
		if (args.length > 0)
			inputFile = args[0];
		InputStream is = System.in;
		if (inputFile != null) {
			is = new FileInputStream(inputFile);
		}
		ANTLRInputStream input = new ANTLRInputStream(is);
		FsmLexer lexer = new FsmLexer(input);
		CommonTokenStream tokens = new CommonTokenStream(lexer);
		FsmParser parser = new FsmParser(tokens);
		parser.setBuildParseTree(true);
		ParseTree tree = parser.file();

		// show tree in text form
		// System.out.println(tree.toStringTree(parser));

		ParseTreeWalker walker = new ParseTreeWalker();
		FunctionListener collector = new FunctionListener();
		bufVhdl = new StringBuilder();

		bufDot = new StringBuilder();

		walker.walk(collector, tree);
		// pour affichage en chaine
		// System.out.println(collector.graph.toString());
		// pour affichage en .DOT
		// System.out.println(collector.graph.toDOT());

		// Here's another example that uses StringTemplate to generate output
		// System.out.println(collector.graph.toST().render());


 		generateDot();
 		System.out.println(bufDot.toString());

		 generateVhdl();
		 System.out.println(bufVhdl);

		/*
		System.out.println("Liste des actions");
		for (int n=0;n<outputList.size();n++)
			System.out.println(outputList.get(n));
		System.out.println("Liste des entrées");
		for (int n=0;n<inputList.size();n++)
			System.out.println(inputList.get(n));
		 */
	}
}
